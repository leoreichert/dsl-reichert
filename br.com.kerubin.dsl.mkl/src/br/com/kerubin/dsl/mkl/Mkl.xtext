grammar br.com.kerubin.dsl.mkl.Mkl with org.eclipse.xtext.common.Terminals

//generate mkl "http://www.com.br.kerubin/dsl/mkl/Mkl"
import "br.com.kerubin.dsl.mkl.model"

DomainModel:
	'domain' Name
	service = Service
 ; 

Service:
	'microservice' Name '{'
		configuration=Configuration
		(elements+=(Entity | PublicObject | Enumeration)*)
	'}'
;

Configuration:
	'config' '{' 
		'groupId' ':' groupId=STRING
		'version' ':' version=STRING
		'cloudConfigUri' ':' cloudConfigUri=STRING
	'}'
;

/*ParentModule:
	'parentModule' '{'
		'groupId' ':' groupId=STRING
		'artifactId' ':' artifactId=STRING
		'version' ':' version=STRING
	'}'
;*/

Enumeration:
	'enum' Name '{'
		items+=EnumItem*
	'}'
;

EnumItem:
	name=ID ('as' valueStr=STRING)? ('=' valueInt=INT)? | (',' EnumItem)
;

Entity:
	(
		(externalObject=ExternalObject)? & 
		(secure?='@secure')? &
		(mapped?='@mapped')? &
		(baseRepository?='@baseRepository')? &
		(audit?='@audit')? &
		('@parent' '(' parent=[Entity] ')')?
	)
	'entity' Name ('extends' superType=[Entity] )? '{'
		Slots
	'}'
;

ExternalObject:
	external?='@external' '(' 'domain' '=' externalDomain=ID ',' 'service' '=' externalService=ID ')'
;

PublicObject:
	'object' Name ('extends' superType=[PublicObject] )? '{'
		Slots
	'}'
;

 fragment Name returns Named:
	name=ID ('alias' _alias=ID)?
;

fragment Slots returns Slotted:
	slots+=Slot*
;

Slot:
	Name ':' (associationType=AssociationType)? 
		(parent ?= 'parent')?
		slotType=TypeReference 
		(optional?='?')? (many?='*')? 
		(relationship = Relationship)? 
		(
			(autoComplete = AutoComplete)? &
			('stored' ':' enumType=EnumType)? &
			(indexed?='indexed')? &
			//(lookupKey?='lookupKey')? &
			//(lookupResult?='lookupResult')? &
			('label' ':' label=STRING)? &
			('help' ':' help=STRING)?
		)
;

AutoComplete:
{AutoComplete}	
	'autoComplete' ('(' ((key?='key') | (result?='result') | (key?='key' ',' result?='result')) ')')?
;

Relationship:
	OneToOne | OneToMany | ManyToOne | ManyToMany
;

OneToOne:
{OneToOne}
	'oneToOne' | 'oneToOne' RelationshipFeature
;

OneToMany:
{OneToMany}
	'oneToMany' | 'oneToMany' RelationshipFeature
;

ManyToOne:
{ManyToOne}
	'manyToOne' | 'manyToOne' RelationshipFeature
;

ManyToMany:
	'manyToMany' RelationshipFeature
;

fragment RelationshipFeature returns RelationshipFeatured:
	'(' 
		('opposite' ':' field=[Slot])? &
		('fetch' ':' fetchType=FetchType)? &
		(owner?='owner')? &
		(orphanRemoval?='orphanRemoval')? &
		('cascade' ':' '[' cascadeType+=CascadeType (',' cascadeType+=CascadeType)* ']')?
	')'
;

enum CascadeType:
	 ALL='all' | DETACH='detach' | MERGE='merge' | PERSIST='persist' | REFRESH='refresh' | REMOVE='remove'
;

enum EnumType:
	STRING='string' | ORDINAL='ordinal'
;



TypeReference:
	BasicTypeReference | ObjectTypeReference
;

ObjectTypeReference:
	referencedType=[ServiceObject] 
;

enum FetchType:
	EAGER='eager' | LAZY='lazy'
;

enum AssociationType:
	CONTAINS = 'contains' |	REFERS = 'refers'
;

ServiceObject:
	PublicObject | Entity
;

BasicTypeReference:
	basicType=BasicType
;

BasicType:
	StringType | IntegerType | DoubleType | MoneyType | BooleanType | DateType | TimeType | DateTimeType | UUIDType | ByteType
;

StringType: name='string' ('[' length=INT ']')?;
IntegerType: name='integer' (generated ?='generated')?;
DoubleType: name='double';
MoneyType: name='money';
BooleanType: name='boolean';
DateType: name='date';
TimeType: name='time';
DateTimeType: name='dateTime';
UUIDType: name='uuid' (generated ?='generated')?;
ByteType: name='byte';

 
 