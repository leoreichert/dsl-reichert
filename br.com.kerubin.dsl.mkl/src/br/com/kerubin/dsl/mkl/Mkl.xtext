grammar br.com.kerubin.dsl.mkl.Mkl with org.eclipse.xtext.common.Terminals

//generate mkl "http://www.com.br.kerubin/dsl/mkl/Mkl"
import "br.com.kerubin.dsl.mkl.model"
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

DomainModel:
	'domain' Name
	service = Service
 ; 

Service:
	'service' Name '{'
		( 
			(configuration=Configuration)? &
			(dependencies+=MavenDependency)? & 
			(elements+=(Entity | PublicObject | Enumeration)*) 
		)
	'}'
;

MavenDependency:
	'dependency' '{'
		'groupId' ':' groupId=STRING
		'artifactId' ':' artifactId=STRING
		'version' ':' version=STRING
	'}' 
;

Configuration:
	'config' '{'
	(
		('groupId' ':' groupId=STRING) &
		('version' ':' version=STRING) &
		('servicePort' ':' servicePort=INT) & 
		('cloudConfigUri' ':' cloudConfigUri=STRING) &
		('messaging' '{' 'version' ':' messagingVersion=STRING '}')
	)
		
	'}'
;

Enumeration:
	'enum' Name '{'
		items+=EnumItem*
	'}'
;

EnumItem:
	name=ID ('as' valueStr=STRING)? ('=' valueInt=INT)? | (',' EnumItem)
;

Entity:
	(
		(externalEntity?='@externalEntity')? &
		(subscribeEntityEvents=SubscribeEntityEvents)? & 
		(publishEntityEvents=PublishEntityEvents)? & 
		(enableReplication?='@enableReplication')? &
		(secure?='@secure')? &
		(mapped?='@mapped')? &
		(baseRepository?='@baseRepository')? &
		(audit?='@audit')? &
		('@parent' '(' parent=[Entity] ')')? &
		('@label' '(' label=STRING ')')?
	)
	'entity' Name ('extends' superType=[Entity] )? '{'
		Slots
		Rules?
	'}'
;



SubscribeEntityEvents:
	'@subscribe' '(' 'domain' '=' externalDomain=ID ',' 'service' '=' externalService=ID ',' 'events' '=' '[' events=CudEvents ']' ')'
;

PublishEntityEvents:
{PublishEntityEvents}
	'@publish' ('(' 'events' '=' '[' events=CudEvents ']' ')')?
;

CudEvents:
{CudEvents}
		(cud?='cud') | 
		(
			(created?='created') |
			(created?='created' ',' updated?='updated') |
			(created?='created' ',' updated?='updated' ',' deleted?='deleted') |
			(updated?='updated') |
			(updated?='updated' ',' deleted?='deleted') |
			(updated?='created' ',' deleted?='deleted') |
			(deleted?='deleted') 
		)
;

PublicObject:
	'object' Name ('extends' superType=[PublicObject] )? '{'
		Slots
	'}'
;

 fragment Name returns Named:
	name=ID ('alias' _alias=ID)?
;

fragment Slots returns Slotted:
	slots+=Slot*
;

Slot:
	Name ':' (associationType=AssociationType)? 
		(parent ?= 'parent')?
		slotType=TypeReference 
		(optional?='?')? (many?='*')? 
		(relationship = Relationship)? 
		(
			(autoComplete = AutoComplete)? &
			(listFilter = ListFilter)? &
			('enumType' ':' enumType=EnumType)? &
			(indexed?='indexed')? &
			(lookupKey?='lookupKey')? &
			(lookupResult?='lookupResult')? &
			('help' ':' help=STRING)? &
			('label' ':' label=STRING)? &
			('labelGrid' ':' labelGrid=STRING)? &
			(sumField = SumField)? &
			('mask' ':' mask=STRING)? &
			(^hidden ?= 'hidden')? &
			(publish ?= 'publish')? &
			(grid = Grid)? &
			(web = Web)? 
		)
;

fragment Rules returns Rulled:
	'rules' '{' rules += Rule* '}'
;

// BEGIN rule
Rule:
	'with' '(' (targets += RuleTarget (',' targets += RuleTarget)*)? ')'
	'.' 'apply' '(' apply = RuleApply ')'
	('.' 'when' '(' when = RuleWhen ')')?
	('.' 'action' '(' action = RuleAction ')')?
;

RuleAction:
	'name' ':' actionName = ID 
	'button' '(' actionButton = ActionButton ')'
;

ActionButton:
	(
		('tooltip' ':' tooltip = STRING) & 
		('label' ':' label = STRING)? & 
		('icon' ':' icon = STRING)?
	)
;

RuleWhen:
{RuleWhen}
	expression = RuleWhenExpression	
;

RuleWhenExpression:
	left = RuleExpression
		 ( operator = RuleWhenOperator rigth = RuleWhenExpression )?
;

RuleExpression:
	(whenObject = (FieldObject | TemporalObject | NumberObject)) 
		('.' objectOperation = RuleWhenAbstractObjectOperation)?
;

RuleWhenAbstractObjectOperation:
	RuleWhenOpIsBetween | 
	RuleWhenOpIsSame | 
	RuleWhenOpIsBefore | 
	RuleWhenOpIsNull |
	RuleWhenOpIsNotNull
;

RuleWhenOpIsNull:
	methodName = 'isNull'
;

RuleWhenOpIsNotNull:
	methodName = 'isNotNull'
;

RuleWhenOpIsBetween:
	methodName = 'isBetween' '(' betweenFrom = RuleWhenTemporalValue ',' betweenTo = RuleWhenTemporalValue ')'
;

RuleWhenOpIsSame:
	methodName = 'isSame' '(' valueToCompare = RuleWhenTemporalValue ')'
;

RuleWhenOpIsBefore:
	methodName = 'isBefore' '(' valueToCompare = RuleWhenTemporalValue ')'
;

RuleWhenOpAddDays:
	methodName = 'addDays' '(' addDaysValue = RuleWhenTemporalValue ')'
;

NullObject:
	nullValue = 'null'
;

FieldObject:
	field=[Slot]
;

RuleWhenOperator:
{RuleWhenOperator}	
	operator = ('and' | 'or' /* | 'not'*/ | '==' | '>' | '<' | '<=' | '>=')
;

NumberObject:
	value = EDoubleType
;

EDoubleType returns ecore::EDouble:
	INT ('.' INT)?
;

TemporalObject:
	temporalConstant = RuleWhenTemporalConstants
;

enum RuleWhenTemporalConstants:
	TODAY='today' | TOMORROW='tomorrow' | YESTERDAY='yesterday' | END_OF_WEEK='endOfWeek'
;

RuleWhenTemporalValue: 
{RuleWhenTemporalValue}
	valueInt = INT | temporalObject = TemporalObject
;

RuleApply:
{RuleApply}	
	(
		('styleClass' ':' styleClass = STRING)? & 
		('styleCss' ':' styleCss = STRING)? &
		('(' sumFieldExpression = FieldMathExpression ')')? &
		(actionExpression = FieldAssignExpression)? &
		(makeCopiesExpression = MakeCopiesExpression)?
	)
;

MakeCopiesExpression:
	'makeCopies' '('
		(
			('grouperField' ':' grouperField = FieldObject) &
			('referenceField' ':' referenceField = FieldObject) &
			('title' ':' title = STRING)? &
			('minCopies' ':' minCopies = INT)? &
			('maxCopies' ':' maxCopies = INT)?
		)
	')'
;

FieldAssignExpression:
	fieldValues += FieldAndValue (',' fieldValues += FieldAndValue)*
;

FieldAndValue:
	field = FieldObject '=' value = (FieldObject | TemporalObject | NumberObject | NullObject)
;

FieldMathExpression:
	leftField = FieldObject 
		(operator = MathOperator rightField = FieldMathExpression)?
;

enum MathOperator:
	PLUS='+' | MINUS='-' | MULTIPLICATION='*' | DIVISION='/'
;

enum RuleTarget:
	 GRID_ROWS='grid.rows' | 
	 GRID_ROW_CELL='grid.row.cell' | 
	 GRID_SUMROW_LAST_CELL = 'grid.sumRow.lastCell' |
	 GRID_ACTIONS = 'grid.actions' |
	 FORM = 'form'
;

//END Rule

SumField:
{SumField}
	'sum'  
	('('
		(
			('styleClass' ':' styleClass = STRING)? &
			('styleCss' ':' styleCss = STRING)? &
			('label' ':' label = STRING)?
		)
	')')?
;


Grid:
{Grid}
	'grid' '('
		(
			(slotIsUnordered ?= 'unordered')? &
			(slotIsHidden ?= 'hidden')? &
			('styleClass' ':' styleClass = STRING)?
		)
	')'
;

Web:
	'web' '('
		(
			('styleClass' ':' styleClass = STRING) &
			('label' ':' label = STRING)?
		)
	')'
;


ListFilter:
{ListFilter}
	'listFilter' '(' 
		filterOperator = FilterOperator
	')'	
;

FilterOperator:
	filterOperatorEnum = FilterOperatorEnum ':' label = STRING ('default' ':' def=STRING)?
;

enum FilterOperatorEnum:
	 many='many' | between='between' | isNotNull='isNotNull' | isNull='isNull' | isNotNull_isNull='isNotNull_isNull'
;

AutoComplete:
{AutoComplete}	
	'autoComplete' ('(' ((key?='key') | (result?='result') | (key?='key' ',' result?='result')) ')')?
;

Relationship:
	OneToOne | OneToMany | ManyToOne | ManyToMany
;

OneToOne:
{OneToOne}
	'oneToOne' | 'oneToOne' RelationshipFeature
;

OneToMany:
{OneToMany}
	'oneToMany' | 'oneToMany' RelationshipFeature
;

ManyToOne:
{ManyToOne}
	'manyToOne' | 'manyToOne' RelationshipFeature
;

ManyToMany:
	'manyToMany' RelationshipFeature
;

fragment RelationshipFeature returns RelationshipFeatured:
	'(' 
		('opposite' ':' field=[Slot])? &
		('fetch' ':' fetchType=FetchType)? &
		(owner?='owner')? &
		(orphanRemoval?='orphanRemoval')? &
		('cascade' ':' '[' cascadeType+=CascadeType (',' cascadeType+=CascadeType)* ']')?
	')'
;

enum CascadeType:
	 ALL='all' | DETACH='detach' | MERGE='merge' | PERSIST='persist' | REFRESH='refresh' | REMOVE='remove'
;

enum EnumType:
	STRING='string' | ORDINAL='ordinal'
;



TypeReference:
	BasicTypeReference | ObjectTypeReference
;

ObjectTypeReference:
	referencedType=[ServiceObject] 
;

enum FetchType:
	EAGER='eager' | LAZY='lazy'
;

enum AssociationType:
	CONTAINS = 'contains' |	REFERS = 'refers'
;

ServiceObject:
	PublicObject | Entity
;

BasicTypeReference:
	basicType=BasicType
;

BasicType:
	StringType | IntegerType | DoubleType | MoneyType | BooleanType | DateType | TimeType | DateTimeType | UUIDType | ByteType
;

StringType: name='string' ('[' length=INT ']')?;
IntegerType: name='integer' (generated ?='generated')?;
DoubleType: name='double';
MoneyType: name='money';
BooleanType: name='boolean';
DateType: name='date';
TimeType: name='time';
DateTimeType: name='dateTime';
UUIDType: name='uuid' (generated ?='generated')?;
ByteType: name='byte';

 
 