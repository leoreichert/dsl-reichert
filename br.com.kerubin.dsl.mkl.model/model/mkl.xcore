package br.com.kerubin.dsl.mkl.model

import java.util.Set
import java.util.LinkedHashSet

class DisableServiceGeneration {
	boolean backend
	boolean frontend
	
	// All means, have no other
	op boolean isAll() {
		return !backend &&
			!frontend
	}
}

class DisableEntityGeneration {
	boolean controller
	boolean entityJPA
	boolean repository
	boolean serviceInterface
	boolean serviceImpl
	boolean entityDTO
	
	// All means, have no other
	op boolean isAll() {
		return !controller &&
			!entityJPA &&
			!entityDTO &&
			!repository &&
			!serviceInterface &&
			!serviceImpl 
	}
}

// BEGIN Rule

class MakeCopiesExpression {
	String title
	int minCopies = '1'
	int maxCopies = '60'
	contains FieldObject referenceField
	contains FieldObject grouperField
	
	op boolean hasTitle() {
		title !== null && !title.trim.empty
	}
}

class RuleAction {
	String actionName
	contains ActionButton actionButton
}

class ActionButton {
	String tooltip
	String icon
	String label
}

class FieldAssignExpression {
	contains FieldAndValue[] fieldValues
}

class FieldAndValue {
	contains FieldObject field
	contains AbstractObject value
}

class Rulled {
	contains Rule[] rules opposite owner
	
	op boolean hasRules() {
		rules !== null
	}
}

class Rule {
	RuleTarget[] targets
	contains RuleApply apply
	contains RuleWhen when
	contains RuleAction action
	container Rulled owner opposite rules
	
	op boolean hasWhen() {
		when !== null
	}
}

class RuleWhen {
	contains RuleWhenExpression expression
}

class RuleWhenExpression {
	contains RuleExpression left
	contains RuleWhenOperator operator
	contains RuleWhenExpression rigth
}

class RuleExpression {
	contains AbstractObject whenObject
	contains RuleWhenAbstractObjectOperation objectOperation
}

class FieldMathExpression {
	contains FieldObject leftField
	MathOperator operator
	contains FieldMathExpression rightField
}

abstract class AbstractObject {
	
}

class FieldObject extends AbstractObject {
	refers Slot field
}

class NumberObject extends AbstractObject {
	Double value
}

class NullObject extends AbstractObject {
	String nullValue
}

class TemporalObject extends AbstractObject {
	RuleWhenTemporalConstants temporalConstant
}

abstract class RuleWhenAbstractObjectOperation {
	String methodName
}

class RuleWhenOpAddDays extends RuleWhenAbstractObjectOperation {
	contains RuleWhenTemporalValue addDaysValue
}

class RuleWhenOpIsBetween extends RuleWhenAbstractObjectOperation {
	contains RuleWhenTemporalValue betweenFrom
	contains RuleWhenTemporalValue betweenTo
}

class RuleWhenOpIsSame extends RuleWhenAbstractObjectOperation {
	contains RuleWhenTemporalValue valueToCompare
}

class RuleWhenOpIsBefore extends RuleWhenAbstractObjectOperation {
	contains RuleWhenTemporalValue valueToCompare
}

class RuleWhenOpIsNull extends RuleWhenAbstractObjectOperation {
	
}

class RuleWhenOpIsNotNull extends RuleWhenAbstractObjectOperation {
	
}


class RuleWhenTemporalValue {
	contains TemporalObject temporalObject
	int valueInt
}

class RuleWhenOperator {
	String operator
}


enum RuleWhenTemporalConstants {
	TODAY as 'today'
	TOMORROW as 'tomorrow'
	YESTERDAY as 'yesterday' 
	END_OF_WEEK as 'endOfWeek'
}

class RuleApply {
	String styleClass
	String styleCss
	contains FieldMathExpression sumFieldExpression
	contains FieldAssignExpression actionExpression
	contains MakeCopiesExpression makeCopiesExpression
	
	op boolean hasMakeCopiesExpression() {
		makeCopiesExpression !== null
	}
	
	op boolean hasStyleClass() {
		styleClass !== null && !styleClass.trim.isEmpty
	}
	
	op boolean hasStyleCss() {
		styleCss !== null && !styleCss.trim.isEmpty
	}
	
	op String getResutValue() {
		if (hasStyleClass) {
			styleClass
		}
		else {
			styleCss
		}
	}
}

enum MathOperator {
	PLUS as '+'
	MINUS as '-'
	MULTIPLICATION as '*'
	DIVISION as '/'
}

enum RuleTarget {
	GRID_ROWS as 'grid.rows'
	GRID_ROW_CELL as 'grid.row.cell'
	GRID_SUMROW_LAST_CELL as 'grid.sum.lastCell'
	GRID_ACTIONS as 'grid.actions'
	FORM as 'form'
}

// END Rule

abstract class Named {
	String name
	String _alias
	
	op String getAlias() {
		if (_alias === null || _alias.trim.isEmpty) {
			return name
		}
		return _alias
	}
}

class DomainModel extends Named {
	
	op String domain() {
		name
	}
	
	contains Service service opposite domainModel
}

abstract class Element extends Named {
	
}


class Service extends Element {
	container DomainModel domainModel opposite service
	op String domain() {
		//(eContainer as DomainModel).domain
		domainModel.domain
	}
	
	contains DisableServiceGeneration disableGeneration
	contains Configuration configuration
	contains MavenDependency[] dependencies
	contains ServiceElement[] elements opposite service
	
	op boolean notHasDisableGeneration() {
		disableGeneration === null
	}
	
	op boolean canGenerateBackend() {
		val not = isGenerationDisabled() || (hasDisableGeneration && disableGeneration.backend)
		!not
	}
	
	op boolean canGenerateFrontend() {
		val not = isGenerationDisabled() || (hasDisableGeneration && disableGeneration.frontend)
		!not
	}
	
	op boolean hasDisableGeneration() {
		disableGeneration !== null
	}
	
	op boolean isGenerationDisabled() {
		hasDisableGeneration && disableGeneration.all
	}
}

class MavenDependency {
	String groupId
	String artifactId
	String version
	
	op String getVersionKey() {
		artifactId.replace('-', '.') + '.version'
	}
	
	op String getVersionFullKey() {
		'${' + getVersionKey + '}'
	}
}

class Configuration {
	String groupId = 'br.com.kerubin.api'
	String version = '1.0.0-SNAPSHOT'
	int servicePort = '9001'
	String cloudConfigUri = 'http://localhost:9091'
	String messagingCoreVersion = '0.0.1-SNAPSHOT'
	String javaVersion = '1.8'
	String springFrameworkBootVersion = '2.0.1.RELEASE'
	String springCloudVersion = 'Finchley.RC1'
	String springDataReleasetrainVersion = 'Kay-SR6'
	String queryDSLVersion = '4.2.1'
	String apacheCommonsLangVersion = '3.8.1'
	String databaseCoreVersion = '1.0.0'
	String flywayCoreVersion = '5.2.4'
	String modelMapperVersion = '1.1.0'
	String buildHelperMavenPluginVersion = '3.0.0'
	String aptMavenPluginVersion = '1.1.1'
	String templatingMavenPluginVersion = '1.0.0'
}

abstract class ServiceElement extends Element {
	container Service service opposite elements
}

abstract class TypeReference {
	refers Slot ownerSlot opposite slotType
}

class ObjectTypeReference extends TypeReference {
	refers ServiceElement referencedType
}

enum FetchType {
	LAZY as 'lazy'
	EAGER as 'eager' 
}

enum AssociationType {
	CONTAINS as 'contains' 
	REFERS as 'refers'
}

enum CascadeType {
	ALL as 'all'
	DETACH as'detach' 
	MERGE as 'merge'
	PERSIST as 'persist'
	REFRESH as 'refresh'
	REMOVE as 'remove'
}

class BasicTypeReference extends TypeReference {
	contains BasicType basicType
}

abstract class ServiceObject extends ServiceElement {
	
}

class SubscribeEntityEvents {
	String externalDomain
	String externalService
	contains CudEvents events
}

class PublishEntityEvents {
	contains CudEvents events
}

class CudEvents {
	boolean cud = 'false'
	boolean created = 'false'
	boolean updated = 'false'
	boolean deleted = 'false'
}


class AutoComplete {
	boolean key
	boolean result
}

enum FilterOperatorEnum {
	many as 'many' 
	between as 'between'
	isNotNull as 'isNotNull'
	isNull as 'isNull'
	isNotNull_isNull as 'isNotNull_isNull'
}

class FilterOperator {
	FilterOperatorEnum filterOperatorEnum
	String label
	String def //default
	
	op String getDefault() {
		if (def !== null) {
			return def			
		}
		
		switch(FilterOperatorEnum) {
			case FilterOperatorEnum.IS_NOT_NULL,
			case FilterOperatorEnum.IS_NULL,
			case FilterOperatorEnum.IS_NOT_NULL_IS_NULL: {
				return FilterOperatorEnum.IS_NULL.literal
			}
			
			default: return null
		}
	}
}

class ListFilter {
	contains FilterOperator filterOperator
}

class SumField {
	String styleClass
	String styleCss
	String label
	
	op boolean hasStyleCss() {
		styleCss !== null && !styleCss.trim.isEmpty 
	}
	
	op boolean hasStyleClass() {
		styleClass !== null && !styleClass.trim.isEmpty
	}
	
	op boolean hasLabel() {
		label !== null && !label.trim.isEmpty
	}
}

class Grid {
	boolean slotIsHidden
	boolean slotIsUnordered
	String styleClass
}

class Web {
	String styleClass
	String label
}

abstract class Slotted extends Element {
	contains Slot[] slots opposite ownerObject
}

class Slot extends Element {
	contains TypeReference slotType opposite ownerSlot
	boolean implicit = 'false'
	boolean optional
	boolean parent
	boolean many
	boolean indexed
	Boolean hidden
	boolean publish = 'false'
	boolean mapped = 'false'
	
	boolean lookupKey
    boolean lookupResult
	
	contains SumField sumField
	contains AutoComplete autoComplete
	contains ListFilter listFilter
	contains Web web
	contains Grid grid
	AssociationType associationType
	EnumType enumType
	
	String help
	String label
	String labelGrid
	String mask
	contains Relationship relationship opposite ownerSlot
	String[] annotations
	container Slotted ownerObject opposite slots
	
	op boolean isRequired() {
		!optional
	}
	
	op boolean hasSumField() {
		sumField !== null
	}
	
	op boolean isHiddenSlot() {
		hidden !== null && hidden
	}
	
	op boolean hasMask() {
		return mask !== null && !mask.trim.isEmpty
	}
	
	op boolean isShowOnGrid() {
		return !hasGrid || !grid.isSlotIsHidden 
	}
	
	op boolean hasGridStyleClass() {
		return hasGrid && grid.styleClass !== null && !grid.styleClass.trim.isEmpty 
	}
	
	op boolean isOrderedOnGrid() {
		return !hasGrid || !grid.isSlotIsUnordered
	}
	
	op boolean hasLabel() {
		return label !== null && !label.trim.isEmpty
	}
	
	op boolean hasLabelGrid() {
		return labelGrid !== null && !labelGrid.trim.isEmpty
	}
	
	op boolean hasGrid() {
		return grid !== null
	}
	
	op boolean hasWeb() {
		return web !== null
	}
	
	op boolean hasWebClass() {
		return web !== null && web.getStyleClass !== null
	}
	
	op boolean hasWebLabel() {
		return web !== null && web.label !== null
	}
	
	
	op boolean isString() {
		if (this.slotType instanceof BasicTypeReference) {
			val basicType = (this.slotType as BasicTypeReference).basicType
			return basicType instanceof StringType
		}
		
		false
	}
	
	op boolean isUUID() {
		if (this.slotType instanceof BasicTypeReference) {
			val basicType = (this.slotType as BasicTypeReference).basicType
			return basicType instanceof UUIDType
		}
		
		false
	}
	
	op boolean isDate() {
		if (this.slotType instanceof BasicTypeReference) {
			val basicType = (this.slotType as BasicTypeReference).basicType
			return basicType instanceof DateType
		}
		
		false
	}
	
	op boolean isNumber() {
		if (this.slotType instanceof BasicTypeReference) {
			val basicType = (this.slotType as BasicTypeReference).basicType
			return basicType instanceof IntegerType || 
			basicType instanceof MoneyType || 
			basicType instanceof DoubleType || 
			basicType instanceof ByteType
		}
		
		false
	}
	
	op boolean isMoney() {
		if (this.slotType instanceof BasicTypeReference) {
			val basicType = (this.slotType as BasicTypeReference).basicType
			return basicType instanceof MoneyType
		}
		
		false
	}
	
	op boolean isBoolean() {
		if (this.slotType instanceof BasicTypeReference) {
			val basicType = (this.slotType as BasicTypeReference).basicType
			return basicType instanceof BooleanType
		}
		
		false
	}
	
	op boolean isListFilterMany() {
		hasListFilter() && this.listFilter.filterOperator.filterOperatorEnum == FilterOperatorEnum.MANY
	}
	
	op boolean hasListFilter() {
		return this.listFilter !== null
	}
	
	op boolean hasAutoComplete() {
		return this.getAutoComplete !== null
	}
	
	op boolean isAutoCompleteResult() {
		return hasAutoComplete() && (this.getAutoComplete.isResult || (!this.getAutoComplete.isResult && !this.getAutoComplete.isKey))
	}
	
	op boolean isAutoCompleteKey() {
		return hasAutoComplete() && (this.getAutoComplete.isKey || (!this.getAutoComplete.isResult && !this.getAutoComplete.isKey))
	}
	
	op boolean isRelationContains() {
		return associationType === null || associationType == AssociationType.CONTAINS
	}
	
	op boolean isRelationRefers() {
		return associationType !== null && associationType == AssociationType.REFERS
	}
	
	op boolean isRelationOwner() {
		return relationship !== null && (relationship as RelationshipFeatured).owner
	}
	
	op boolean isOrphanRemoval() {
		return relationship !== null && (relationship as RelationshipFeatured).orphanRemoval
	}
	
}

class EnumTypeReference extends TypeReference {
	refers ServiceElement referencedType
}

class Enumeration extends ServiceObject {
	contains EnumItem[] items
	
	op boolean hasSomeValueStr() {
		items.exists[hasValueStr]
	}
}

class EnumItem {
	String name
	String valueStr
	String label
	int valueInt
	
	op boolean hasLabel() {
		label !== null && !label.trim.isEmpty
	}
	
	op boolean hasValueStr() {
		valueStr !== null && !valueStr.trim.isEmpty
	}
}

enum EnumType {
	STRING as 'string' 
	ORDINAL as 'ordinal'
}

abstract class Record extends Slotted {
	refers PublicObject[0..1] superType
}

class PublicObject extends Record, ServiceObject {
	ESet<String> _imports
	
	op void addImport(String import_) {
		imports.add(import_)
	}
		
	op ESet<String> getImports() {
		if (_imports === null) {
			_imports = new LinkedHashSet()
		}
		return _imports
	}
	
}

class Entity extends PublicObject, Rulled {
	refers Entity parent
	boolean secure
	boolean auditing
	boolean mapped
	boolean baseRepository
	boolean enableReplication
	boolean externalEntity = 'false'
	String label
	contains SubscribeEntityEvents subscribeEntityEvents
	contains PublishEntityEvents publishEntityEvents
	contains DisableEntityGeneration disableGeneration
	
	op boolean hasDisableGeneration() {
		disableGeneration !== null
	}
	
	op boolean notHasDisableGeneration() {
		disableGeneration === null
	}
	
	op boolean isGenerationDisabled() {
		hasDisableGeneration && disableGeneration.all
	}
	
	//contains Rulled rules
	
	op boolean hasSumFields() {
		slots.exists[hasSumField]
	}
	
	op boolean hasSubscribeCreated() {
		subscribeEntityEvents !== null && (
			subscribeEntityEvents.events === null || 
			subscribeEntityEvents.events.cud ||
			subscribeEntityEvents.events.created
		)
	}
	
	op boolean hasSubscribeUpdated() {
		subscribeEntityEvents !== null && (
			subscribeEntityEvents.events === null || 
			subscribeEntityEvents.events.cud ||
			subscribeEntityEvents.events.updated
		)
	}
	
	op boolean hasSubscribeDeleted() {
		subscribeEntityEvents !== null && (
			subscribeEntityEvents.events === null || 
			subscribeEntityEvents.events.cud ||
			subscribeEntityEvents.events.deleted
		)
	}
	
	op boolean hasPublishCreated() {
		publishEntityEvents !== null && (
			publishEntityEvents.events === null || 
			publishEntityEvents.events.cud ||
			publishEntityEvents.events.created
		)
	}
	
	op boolean hasPublishUpdated() {
		publishEntityEvents !== null && (
			publishEntityEvents.events === null || 
			publishEntityEvents.events.cud ||
			publishEntityEvents.events.updated
		)
	}
	
	op boolean hasPublishDeleted() {
		publishEntityEvents !== null && (
			publishEntityEvents.events === null || 
			publishEntityEvents.events.cud ||
			publishEntityEvents.events.deleted
		)
	}
	
	op Slot getFirstSlot() {
		val slot = slots.tail.head ?: slots.head
		slot
	}
	
	op boolean hasAutoComplete() {
		return !slots.filter[it.isAutoCompleteResult].empty
	}
	
	op boolean hasListFilter() {
		return !slots.filter[it.hasListFilter].empty
	}
	
	op boolean hasListFilterMany() {
		return hasListFilter() && !slots.filter[it.isListFilterMany].empty
	}
	
	op Slot getId() {
		return slots.head
	}
	
	op boolean hasId() {
		val idSlot =  slots.head
		
		val result = idSlot !== null && 'id'.equals(idSlot.name.toLowerCase) && idSlot.isUUID
		return result
	}
	
	op Slot[] getTailSlots() {
		return slots.tail.asEList
	}
	
	op boolean hasSubscribeEntityEvents() {
		return subscribeEntityEvents !== null
	}
	
	op boolean hasPublishEntityEvents() {
		return publishEntityEvents !== null
	}
	
}

abstract class Relationship {
	refers Slot ownerSlot opposite relationship	
}

class RelationshipFeatured extends Relationship {
	refers Slot field
	FetchType fetchType
	CascadeType[] cascadeType
	boolean owner
	boolean orphanRemoval
}

class OneToOne extends RelationshipFeatured {
	
}

class OneToMany extends RelationshipFeatured {
	
}

class ManyToOne extends RelationshipFeatured {
	
}

class ManyToMany extends RelationshipFeatured {
	
}

abstract class BasicType extends Named {
	op String getJavaType() {
		return ""
	}
}

abstract class generatedType extends BasicType {
	boolean generated
}

class StringType extends generatedType {
	int length = "255"
}

class IntegerType extends generatedType {
	
}

class DoubleType extends BasicType {
	
}

class MoneyType extends BasicType {
	
}

class BooleanType extends BasicType {
	
}

class DateType extends BasicType {
	
}

class TimeType extends BasicType {
	
}

class DateTimeType extends BasicType {
	
}

class UUIDType extends generatedType {
	
}

class ByteType extends BasicType {
	
}

type ESet<T> wraps Set
create {
	
}